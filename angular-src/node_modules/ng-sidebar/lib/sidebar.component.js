"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var core_1 = require("@angular/core");
var platform_browser_1 = require("@angular/platform-browser");
var sidebar_service_1 = require("./sidebar.service");
var Sidebar = (function () {
    function Sidebar(_document /*: HTMLDocument */, _sidebarService) {
        this._document = _document; /*: HTMLDocument */
        this._sidebarService = _sidebarService;
        // `openedChange` allows for "2-way" data binding
        this.opened = false;
        this.openedChange = new core_1.EventEmitter();
        this.mode = 'over';
        this.dockedSize = '0px';
        this.position = 'start';
        this.animate = true;
        this.trapFocus = true;
        this.autoFocus = true;
        this.showBackdrop = false;
        this.closeOnClickOutside = false;
        this.keyClose = false;
        this.keyCode = 27; // Default to ESCAPE key
        this.onOpenStart = new core_1.EventEmitter();
        this.onOpened = new core_1.EventEmitter();
        this.onCloseStart = new core_1.EventEmitter();
        this.onClosed = new core_1.EventEmitter();
        this.onModeChange = new core_1.EventEmitter();
        this.onPositionChange = new core_1.EventEmitter();
        this._focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]),' +
            'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
        this._clickEvent = 'click';
        this._onClickOutsideAttached = false;
        this._onKeyDownAttached = false;
        if (this._isIOS() && 'ontouchstart' in window) {
            this._clickEvent = 'touchstart';
        }
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this._onTransitionEnd = this._onTransitionEnd.bind(this);
        this._onFocusTrap = this._onFocusTrap.bind(this);
        this._onClickOutside = this._onClickOutside.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._openSub = this._sidebarService.onOpen(this.open);
        this._closeSub = this._sidebarService.onClose(this.close);
    }
    Sidebar.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes['opened']) {
            if (changes['opened'].currentValue) {
                this.open();
            }
            else {
                this.close();
            }
        }
        if (changes['closeOnClickOutside'] || changes['keyClose']) {
            this._initCloseListeners();
        }
        if (changes['position']) {
            // Handle "start" and "end" aliases
            if (this.position === 'start') {
                this.position = this._isLTR ? 'left' : 'right';
            }
            else if (this.position === 'end') {
                this.position = this._isLTR ? 'right' : 'left';
            }
            // Emit change in timeout to allow for position change to be rendered first
            setTimeout(function () {
                _this.onPositionChange.emit(changes['position'].currentValue);
            });
        }
        if (changes['mode']) {
            this.onModeChange.emit(changes['mode'].currentValue);
        }
    };
    Sidebar.prototype.ngOnDestroy = function () {
        this._destroyCloseListeners();
        this._openSub.unsubscribe();
        this._closeSub.unsubscribe();
    };
    // Sidebar toggling
    // ==============================================================================================
    /**
     * Opens the sidebar and emits the appropriate events.
     */
    Sidebar.prototype.open = function () {
        var _this = this;
        this.opened = true;
        this.openedChange.emit(true);
        this.onOpenStart.emit();
        this._elSidebar.nativeElement.addEventListener('transitionend', this._onTransitionEnd);
        this._setFocused();
        this._initCloseListeners();
        if (!this.animate) {
            setTimeout(function () {
                if (_this.opened) {
                    _this.onOpened.emit();
                }
            });
        }
    };
    /**
     * Closes the sidebar and emits the appropriate events.
     */
    Sidebar.prototype.close = function () {
        var _this = this;
        this.opened = false;
        this.openedChange.emit(false);
        this.onCloseStart.emit();
        this._elSidebar.nativeElement.addEventListener('transitionend', this._onTransitionEnd);
        this._setFocused();
        this._destroyCloseListeners();
        if (!this.animate) {
            setTimeout(function () {
                if (!_this.opened) {
                    _this.onClosed.emit();
                }
            });
        }
    };
    /**
     * @internal
     *
     * Computes the transform styles for the sidebar template.
     *
     * @return {CSSStyleDeclaration} The transform styles, with the WebKit-prefixed version as well.
     */
    Sidebar.prototype._getStyle = function () {
        var transformStyle = 'none';
        var marginStyle = {};
        if (!this.opened) {
            transformStyle = "translate" + ((this.position === 'left' || this.position === 'right') ? 'X' : 'Y');
            var isLeftOrTop = this.position === 'left' || this.position === 'top';
            var isDockMode = this.mode === 'dock';
            // We use 110% for non-docked modes in an attempt to hide any box-shadow
            var translateAmt = "" + (isLeftOrTop ? '-' : '') + (isDockMode ? '100' : '110') + "%";
            if (isDockMode && parseFloat(this.dockedSize) > 0) {
                var marginPos = "margin" + this._upperCaseFirst(this.position);
                marginStyle = (_a = {},
                    _a[marginPos] = this.dockedSize,
                    _a);
            }
            transformStyle += "(" + translateAmt + ")";
        }
        return Object.assign(marginStyle, {
            webkitTransform: transformStyle,
            transform: transformStyle
        });
        var _a;
    };
    /**
     * @internal
     *
     * Handles the `transitionend` event on the sidebar to emit the onOpened/onClosed events after
     * the transform transition is completed.
     */
    Sidebar.prototype._onTransitionEnd = function (e) {
        if (e.target === this._elSidebar.nativeElement && e.propertyName.endsWith('transform')) {
            if (this.opened) {
                this.onOpened.emit();
            }
            else {
                this.onClosed.emit();
            }
            this._elSidebar.nativeElement.removeEventListener('transitionend', this._onTransitionEnd);
        }
    };
    Object.defineProperty(Sidebar.prototype, "_shouldTrapFocus", {
        // Focus on open/close
        // ==============================================================================================
        /**
         * Returns whether focus should be trapped within the sidebar.
         *
         * @return {boolean} Trap focus inside sidebar.
         */
        get: function () {
            return this.opened && this.trapFocus && this._isModeOver;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets focus to the first focusable element inside the sidebar.
     */
    Sidebar.prototype._focusFirstItem = function () {
        if (this._focusableElements && this._focusableElements.length) {
            this._focusableElements[0].focus();
        }
    };
    /**
     * Loops focus back to the start of the sidebar if set to do so.
     */
    Sidebar.prototype._onFocusTrap = function (e) {
        if (this._shouldTrapFocus && !this._elSidebar.nativeElement.contains(e.target)) {
            this._focusFirstItem();
        }
    };
    /**
     * Handles the ability to focus sidebar elements when it's open/closed to ensure that the sidebar is inert
     * when appropriate.
     */
    Sidebar.prototype._setFocused = function () {
        this._focusableElements = Array.from(this._elSidebar.nativeElement.querySelectorAll(this._focusableElementsString));
        if (this.opened) {
            this._focusedBeforeOpen = this._document.activeElement;
            // Restore focusability, with previous tabindex attributes
            for (var _i = 0, _a = this._focusableElements; _i < _a.length; _i++) {
                var el = _a[_i];
                var prevTabIndex = el.getAttribute('__tabindex__');
                if (prevTabIndex) {
                    el.setAttribute('tabindex', prevTabIndex);
                    el.removeAttribute('__tabindex__');
                }
                else {
                    el.removeAttribute('tabindex');
                }
            }
            if (this.autoFocus) {
                this._focusFirstItem();
            }
            this._document.addEventListener('focus', this._onFocusTrap, true);
        }
        else {
            // Manually make all focusable elements unfocusable, saving existing tabindex attributes
            for (var _b = 0, _c = this._focusableElements; _b < _c.length; _b++) {
                var el = _c[_b];
                var existingTabIndex = el.getAttribute('tabindex');
                if (existingTabIndex) {
                    el.setAttribute('__tabindex__', existingTabIndex);
                }
                el.setAttribute('tabindex', '-1');
            }
            this._document.removeEventListener('focus', this._onFocusTrap, true);
            // Set focus back to element before the sidebar was opened
            if (this.autoFocus && this._isModeOver && this._focusedBeforeOpen) {
                this._focusedBeforeOpen.focus();
            }
        }
    };
    // Close event handlers
    // ==============================================================================================
    /**
     * Initializes event handlers for the closeOnClickOutside and keyClose options.
     */
    Sidebar.prototype._initCloseListeners = function () {
        var _this = this;
        if (this.opened && (this.closeOnClickOutside || this.keyClose)) {
            // In a timeout so that things render first
            setTimeout(function () {
                if (_this.closeOnClickOutside && !_this._onClickOutsideAttached) {
                    _this._document.addEventListener(_this._clickEvent, _this._onClickOutside);
                    _this._onClickOutsideAttached = true;
                }
                if (_this.keyClose && !_this._onKeyDownAttached) {
                    _this._document.addEventListener('keydown', _this._onKeyDown);
                    _this._onKeyDownAttached = true;
                }
            });
        }
    };
    /**
     * Destroys the event handlers from _initCloseListeners.
     */
    Sidebar.prototype._destroyCloseListeners = function () {
        if (this._onClickOutsideAttached) {
            this._document.removeEventListener(this._clickEvent, this._onClickOutside);
            this._onClickOutsideAttached = false;
        }
        if (this._onKeyDownAttached) {
            this._document.removeEventListener('keydown', this._onKeyDown);
            this._onKeyDownAttached = false;
        }
    };
    /**
     * Handles `click` events on anything while the sidebar is open for the closeOnClickOutside option.
     * Programatically closes the sidebar if a click occurs outside the sidebar.
     *
     * @param e {MouseEvent} Mouse click event.
     */
    Sidebar.prototype._onClickOutside = function (e) {
        if (this._onClickOutsideAttached && this._elSidebar && !this._elSidebar.nativeElement.contains(e.target)) {
            this.close();
        }
    };
    /**
     * Handles the `keydown` event for the keyClose option.
     *
     * @param e {KeyboardEvent} Normalized keydown event.
     */
    Sidebar.prototype._onKeyDown = function (e) {
        e = e || window.event;
        if (e.keyCode === this.keyCode) {
            this.close();
        }
    };
    Object.defineProperty(Sidebar.prototype, "_isDocked", {
        // Helpers
        // ==============================================================================================
        /**
         * Returns whether the sidebar is "docked" -- i.e. it is closed but in dock mode.
         *
         * @return {boolean} Sidebar is docked.
         */
        get: function () {
            return this.mode === 'dock' && this.dockedSize && !this.opened;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_isModeOver", {
        /**
         * Returns whether the sidebar is set to the default "over" mode.
         *
         * @return {boolean} Sidebar mode is "over".
         */
        get: function () {
            return this.mode === 'over';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_height", {
        /**
         * @internal
         *
         * Returns the rendered height of the sidebar (or the docked size).
         * This is used in the sidebar container.
         *
         * @return {number} Height of sidebar.
         */
        get: function () {
            if (this._elSidebar.nativeElement) {
                return this._isDocked ?
                    parseFloat(this.dockedSize) :
                    this._elSidebar.nativeElement.offsetHeight;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_width", {
        /**
         * @internal
         *
         * Returns the rendered width of the sidebar (or the docked size).
         * This is used in the sidebar container.
         *
         * @return {number} Width of sidebar.
         */
        get: function () {
            if (this._elSidebar.nativeElement) {
                return this._isDocked ?
                    parseFloat(this.dockedSize) :
                    this._elSidebar.nativeElement.offsetWidth;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Makes a string's first letter uppercase.
     *
     * @return {string} Original string, but with first letter in upper case.
     */
    Sidebar.prototype._upperCaseFirst = function (str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    };
    Object.defineProperty(Sidebar.prototype, "_isLTR", {
        /**
         * Returns whether the page is in LTR mode. Defaults to `true` if it can't be computed.
         *
         * @return {boolean} Page's language direction is left-to-right.
         */
        get: function () {
            var dir = 'ltr';
            // If `window` doesn't exist, this isn't in the context of a browser...
            if (window) {
                if (window.getComputedStyle) {
                    dir = window.getComputedStyle(this._document.body, null).getPropertyValue('direction');
                }
                else {
                    dir = this._document.body.currentStyle.direction;
                }
            }
            return dir === 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns whether or not the current device is an iOS device.
     *
     * @return {boolean} Device is an iOS device (i.e. iPod touch/iPhone/iPad).
     */
    Sidebar.prototype._isIOS = function () {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    };
    return Sidebar;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "opened", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "openedChange", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Sidebar.prototype, "mode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Sidebar.prototype, "dockedSize", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Sidebar.prototype, "position", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "animate", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Sidebar.prototype, "sidebarClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Sidebar.prototype, "ariaLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "trapFocus", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "autoFocus", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "showBackdrop", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "closeOnClickOutside", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Sidebar.prototype, "keyClose", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Sidebar.prototype, "keyCode", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onOpenStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onOpened", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onCloseStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onClosed", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onModeChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Sidebar.prototype, "onPositionChange", void 0);
__decorate([
    core_1.ViewChild('sidebar'),
    __metadata("design:type", core_1.ElementRef)
], Sidebar.prototype, "_elSidebar", void 0);
Sidebar = __decorate([
    core_1.Component({
        selector: 'ng-sidebar',
        template: "\n    <aside #sidebar\n      role=\"complementary\"\n      [attr.aria-hidden]=\"!opened\"\n      [attr.aria-label]=\"ariaLabel\"\n      class=\"ng-sidebar ng-sidebar--{{opened ? 'opened' : 'closed'}} ng-sidebar--{{position}} ng-sidebar--{{mode}}\"\n      [class.ng-sidebar--inert]=\"!opened && mode !== 'dock'\"\n      [class.ng-sidebar--animate]=\"animate\"\n      [ngClass]=\"sidebarClass\"\n      [ngStyle]=\"_getStyle()\">\n      <ng-content></ng-content>\n    </aside>\n  ",
        styles: ["\n    .ng-sidebar {\n      background-color: #fff;\n      overflow: auto;\n      pointer-events: auto;\n      position: fixed;\n      will-change: initial;\n      z-index: 99999999;\n    }\n\n      .ng-sidebar--left {\n        bottom: 0;\n        left: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--right {\n        bottom: 0;\n        right: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--top {\n        left: 0;\n        right: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--bottom {\n        bottom: 0;\n        left: 0;\n        right: 0;\n      }\n\n    .ng-sidebar--inert {\n      pointer-events: none;\n      will-change: transform;\n    }\n\n    .ng-sidebar--animate.ng-sidebar {\n      -webkit-transition: -webkit-transform 0.3s cubic-bezier(0, 0, 0.3, 1);\n      transition: transform 0.3s cubic-bezier(0, 0, 0.3, 1);\n    }\n  "],
        changeDetection: core_1.ChangeDetectionStrategy.OnPush,
        encapsulation: core_1.ViewEncapsulation.None
    }),
    __param(0, core_1.Inject(platform_browser_1.DOCUMENT)),
    __metadata("design:paramtypes", [Object, sidebar_service_1.SidebarService])
], Sidebar);
exports.Sidebar = Sidebar;
